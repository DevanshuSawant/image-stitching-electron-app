<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="manualstitch.css">
  <meta charset="UTF-8">
  <title>Maual Stitcher</title>
  <script src="https://cdn.jsdelivr.net/npm/konva@8.3.1/konva.min.js"></script>
  <style>
    #container {
      width: 1600px;
      height: 1200px;
      border: 1px solid #ccc;
    }

    .file-input input[type="file"] {
      display: none;
    }
    
  </style>
</head>
<body>
  <div class="buttons">
    <div class="boxy">
      <a href="#" class="box">
        <button onclick="clearImages()" class="box-content">Clear Images</button>
      </a>
      <a href="#" class="box">
        <button onclick="saveImage()" class="box-content">Save Image</button>
      </a>
      <a href="#" class="box">
        <label for="image-upload" class="box-content">Upload Extra Files</label>
        <input type="file" id="image-upload" accept="image/*" multiple class="box-content">
      </a>
      <a href="../index.html" class="box">
        <button class="box-content">
          <p>Go Back ‚Üê</p>
        </button>
      </a>
      <div>
        <label for="opacity">Opacity:</label>
        <input type="range" id="opacityRange" min="0" max="1" step="0.1" value="1" />
      </div>
    </div>
    <hr class="line">
  </div>
  <div id="container"></div>
  <script>
    const { ipcRenderer } = require('electron');
    const fs = require('fs');
    // Create a stage
    var stage = new Konva.Stage({
      container: 'container',
      width: 1600,
      height: 1200
    });

    // Create a layer
    var layer = new Konva.Layer();
    stage.add(layer);

    // Array to store images
    var images = [];

    // Function to load an image
    function loadImage(file) {
        var reader = new FileReader();
        reader.onload = function(event) {
        var imageObj = new Image();
        imageObj.onload = function() {
            var konvaImage = new Konva.Image({
            image: imageObj,
            draggable: true
            });
            konvaImage.on('dragmove', function() {
            lastMovedImage = this; // Update last moved image reference
            });
            images.push(konvaImage);
            layer.add(konvaImage);
            layer.batchDraw();
        };
        imageObj.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    // Request images from the main process
    ipcRenderer.send('getImages');

    // Receive the image paths from the main process
    ipcRenderer.on('imagePaths', (event, imagePaths) => {
        // Load each image using the loadImage function
        imagePaths.forEach(imagePath => {
        fs.readFile(imagePath, (err, data) => {
            if (err) {
            console.error(err);
            return;
            }
            const file = new Blob([data]);
            loadImage(file);
        });
        });
    });

    // Handle image upload
    var imageUpload = document.getElementById('image-upload');
    imageUpload.addEventListener('change', function(event) {
      var files = event.target.files;
      for (var i = 0; i < files.length; i++) {
        loadImage(files[i]);
      }
    });

    var opacityRange = document.getElementById('opacityRange');
    // Register drag events for all images
    layer.on('dragstart', function(event) {
      var image = event.target;
      image.moveToTop();
      
      // Get the opacity value from the range input
      var opacityValue = opacityRange.value;
      image.opacity(opacityValue);

      layer.draw();
    });

    // Reset opacity when drag ends
    layer.on('dragend', function(event) {
      var image = event.target;
      image.opacity(1); // Reset the opacity to 100% (1)

      layer.draw();
    });

    // Add the layer to the stage
    stage.add(layer);


    // Store the original stage size and position
    var originalStageWidth = stage.width();
    var originalStageHeight = stage.height();
    var originalStagePosition = stage.position()

    function saveImage() {
      // Store the current stage scale
      var originalScale = stage.scaleX();

      // Reset the stage scale to 1
      stage.scale({ x: 1, y: 1 });

      // Find the bounding box of all images
      var imageShapes = stage.find('Image');
      
      var minX = Number.MAX_SAFE_INTEGER;
      var minY = Number.MAX_SAFE_INTEGER;
      var maxX = Number.MIN_SAFE_INTEGER;
      var maxY = Number.MIN_SAFE_INTEGER;

      imageShapes.forEach(function(shape) {
        var box = shape.getClientRect();
        minX = Math.min(minX, box.x);
        minY = Math.min(minY, box.y);
        maxX = Math.max(maxX, box.x + box.width);
        maxY = Math.max(maxY, box.y + box.height);
      });

      var boundingBox = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };

      // Adjust the stage size based on the bounding box
      stage.width(boundingBox.width);
      stage.height(boundingBox.height);
      stage.position({
        x: -boundingBox.x,
        y: -boundingBox.y
      });

      // Save the cropped image
      var dataURL = stage.toDataURL({ pixelRatio: 1 });
      var link = document.createElement('a');
      link.href = dataURL;
      link.download = 'image.png';
      link.click();

      // Restore the original stage size and position
      stage.width(originalStageWidth);
      stage.height(originalStageHeight);
      stage.position({ x: 0, y: 0 });
      stage.scale({ x: originalScale, y: originalScale });
    }

    function handleScroll(event) {
      var scaleBy = 1.05;
      event.preventDefault();

      var oldScale = stage.scaleX();
      var mousePointTo = {
        x: stage.getPointerPosition().x / oldScale - stage.x() / oldScale,
        y: stage.getPointerPosition().y / oldScale - stage.y() / oldScale
      };

      var newScale = event.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy;

      stage.scale({ x: newScale, y: newScale });

      var newPos = {
        x: -(mousePointTo.x - stage.getPointerPosition().x / newScale) * newScale,
        y: -(mousePointTo.y - stage.getPointerPosition().y / newScale) * newScale
      };
      stage.position(newPos);
      stage.batchDraw();
    }

    // Add scroll event listener
    var container = document.getElementById('container');
    container.addEventListener('wheel', handleScroll, { passive: false });

    // Remove scroll event listener when dragging
    stage.on('dragstart', function() {
      container.removeEventListener('wheel', handleScroll);
    });

    stage.on('dragend', function() {
      container.addEventListener('wheel', handleScroll, { passive: false });
    });

    function clearImages() {
      layer.removeChildren();
      images = [];
      stage.batchDraw();
    }
  </script>
</body>
</html>
